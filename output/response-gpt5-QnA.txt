Duration: 45.064 seconds.

Code generated:
“DAO”在开发领域里有两个常见含义：
1) 软件工程中的 DAO（Data Access Object，数据访问对象）设计模式
2) 区块链中的 DAO（Decentralized Autonomous Organization，去中心化自治组织）

下面分别介绍并给出示例代码。

一、软件工程中的 DAO 设计模式
- 定义：DAO 是用于隔离业务逻辑与数据持久化细节的抽象层。业务层只依赖 DAO 接口，不关心底层使用的是哪种数据库、驱动或 ORM。
- 优点：
  - 解耦：更易替换存储实现（JDBC、JPA、Mongo、HTTP API 等）
  - 可测试：业务层可通过模拟（mock）DAO 进行单元测试
  - 单一职责：数据访问逻辑集中、可复用
  - 维护性：统一处理事务、连接、异常

Java 示例（JDBC 版本，最小可运行思路）
实体类 User.java
```java
public class User {
    private long id;
    private String name;
    private String email;

    public User() {}
    public User(long id, String name, String email) {
        this.id = id; this.name = name; this.email = email;
    }
    public long getId() { return id; }
    public void setId(long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
```

DAO 接口 UserDao.java
```java
import java.util.*;

public interface UserDao {
    Optional<User> findById(long id);
    List<User> findAll();
    long create(User user);
    boolean update(User user);
    boolean delete(long id);
}
```

JDBC 实现 UserDaoJdbc.java（使用 DataSource）
```java
import javax.sql.DataSource;
import java.sql.*;
import java.util.*;

public class UserDaoJdbc implements UserDao {
    private final DataSource ds;

    public UserDaoJdbc(DataSource ds) {
        this.ds = ds;
    }

    @Override
    public Optional<User> findById(long id) {
        String sql = "SELECT id, name, email FROM users WHERE id = ?";
        try (Connection c = ds.getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setLong(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) return Optional.of(mapRow(rs));
            }
            return Optional.empty();
        } catch (SQLException e) {
            throw new RuntimeException("findById failed", e);
        }
    }

    @Override
    public List<User> findAll() {
        String sql = "SELECT id, name, email FROM users";
        List<User> list = new ArrayList<>();
        try (Connection c = ds.getConnection();
             PreparedStatement ps = c.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {
            while (rs.next()) list.add(mapRow(rs));
            return list;
        } catch (SQLException e) {
            throw new RuntimeException("findAll failed", e);
        }
    }

    @Override
    public long create(User user) {
        String sql = "INSERT INTO users(name, email) VALUES(?, ?)";
        try (Connection c = ds.getConnection();
             PreparedStatement ps = c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            ps.setString(1, user.getName());
            ps.setString(2, user.getEmail());
            ps.executeUpdate();
            try (ResultSet keys = ps.getGeneratedKeys()) {
                if (keys.next()) {
                    long id = keys.getLong(1);
                    user.setId(id);
                    return id;
                }
            }
            throw new RuntimeException("No generated key returned");
        } catch (SQLException e) {
            throw new RuntimeException("create failed", e);
        }
    }

    @Override
    public boolean update(User user) {
        String sql = "UPDATE users SET name = ?, email = ? WHERE id = ?";
        try (Connection c = ds.getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setString(1, user.getName());
            ps.setString(2, user.getEmail());
            ps.setLong(3, user.getId());
            return ps.executeUpdate() == 1;
        } catch (SQLException e) {
            throw new RuntimeException("update failed", e);
        }
    }

    @Override
    public boolean delete(long id) {
        String sql = "DELETE FROM users WHERE id = ?";
        try (Connection c = ds.getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setLong(1, id);
            return ps.executeUpdate() == 1;
        } catch (SQLException e) {
            throw new RuntimeException("delete failed", e);
        }
    }

    private static User mapRow(ResultSet rs) throws SQLException {
        return new User(
            rs.getLong("id"),
            rs.getString("name"),
            rs.getString("email")
        );
    }
}
```

业务层使用 UserService.java
```java
public class UserService {
    private final UserDao userDao;
    public UserService(UserDao userDao) { this.userDao = userDao; }

    public User register(String name, String email) {
        // 这里可以做校验、去重等业务逻辑
        User u = new User(0, name, email);
        userDao.create(u);
        return u;
    }
}
```

简单演示（以 H2 内存库为例）
```java
import org.h2.jdbcx.JdbcDataSource;
import java.sql.Connection;
import java.sql.Statement;

public class Demo {
    public static void main(String[] args) throws Exception {
        JdbcDataSource ds = new JdbcDataSource();
        ds.setURL("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1");

        try (Connection c = ds.getConnection(); Statement st = c.createStatement()) {
            st.execute("CREATE TABLE users (id IDENTITY PRIMARY KEY, name VARCHAR(100), email VARCHAR(100))");
        }

        UserDao userDao = new UserDaoJdbc(ds);
        UserService service = new UserService(userDao);

        User alice = service.register("Alice", "alice@example.com");
        System.out.println("Created: id=" + alice.getId());

        userDao.findById(alice.getId()).ifPresent(u ->
            System.out.println("Found: " + u.getName() + ", " + u.getEmail())
        );
    }
}
```

要点
- 业务层仅依赖 UserDao 接口，切换到 JPA、MyBatis、MongoDB 只需替换实现类
- 便于单元测试：可用内存实现或 mock 实现注入 UserService
- 统一处理数据库资源与异常，避免泄漏

二、区块链中的 DAO（去中心化自治组织）
- 定义：由智能合约驱动、由代币或 NFT 持有者治理的组织。成员通过提案和投票决定资金使用、协议参数等，执行由链上合约自动完成。
- 典型组件：
  - 治理代币（投票权）
  - 提案与投票合约
  - 执行延时与金库（Timelock/Treasury）

Solidity 极简示例（教学用，未做安全/快照/代理升级等生产级处理）
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract SimpleDAO {
    IERC20 public token;

    struct Proposal {
        address payable to;
        uint256 amount;
        string description;
        uint256 deadline;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        mapping(address => bool) voted;
    }

    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;

    event Proposed(uint256 id, address proposer, address to, uint256 amount, string description, uint256 deadline);
    event Voted(uint256 id, address voter, bool support, uint256 weight);
    event Executed(uint256 id);

    constructor(IERC20 _token) {
        token = _token;
    }

    function propose(address payable to, uint256 amount, string calldata description, uint256 votingPeriod)
        external
        returns (uint256 id)
    {
        id = ++proposalCount;
        Proposal storage p = proposals[id];
        p.to = to;
        p.amount = amount;
        p.description = description;
        p.deadline = block.timestamp + votingPeriod;
        emit Proposed(id, msg.sender, to, amount, description, p.deadline);
    }

    function vote(uint256 id, bool support) external {
        Proposal storage p = proposals[id];
        require(block.timestamp < p.deadline, "Voting ended");
        require(!p.voted[msg.sender], "Already voted");
        uint256 weight = token.balanceOf(msg.sender);
        require(weight > 0, "No voting power");
        p.voted[msg.sender] = true;
        if (support) p.forVotes += weight;
        else p.againstVotes += weight;
        emit Voted(id, msg.sender, support, weight);
    }

    function execute(uint256 id) external {
        Proposal storage p = proposals[id];
        require(block.timestamp >= p.deadline, "Not ended");
        require(!p.executed, "Executed");
        require(p.forVotes > p.againstVotes, "Not passed");
        p.executed = true;
        (bool ok, ) = p.to.call{value: p.amount}("");
        require(ok, "Transfer failed");
        emit Executed(id);
    }

    // DAO 金库：向合约转入 ETH
    receive() external payable {}
}
```

说明与改进建议
- 上例用的是“余额加权投票”，未做快照；真实治理建议使用 OpenZeppelin 的 ERC20Votes（快照+委托）、Governor、TimelockController 组件
- 需要加入提案阈值、法定人数、执行延时、多签、可升级性、重入/溢出保护、治理攻击防护等
- 治理代币可用 OpenZeppelin ERC20Votes 铸造，部署后把代币地址传给 SimpleDAO 构造器

如果你明确只需要其中一种“DAO”的更深入示例（比如改成 JPA/SQLAlchemy，或者基于 OpenZeppelin Governor 的完整 DAO），告诉我你的技术栈与要求，我可以按需改写与补充。

